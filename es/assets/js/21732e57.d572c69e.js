"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3014],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),d=o,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return r?n.createElement(f,i(i({ref:t},p),{},{components:r})):n.createElement(f,i({ref:t},p))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},2489:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(7462),o=(r(7294),r(3905));const a={sidebar_position:1,title:"Settings",description:"Librer\xeda de Java para interpretar m\xfaltiples formatos de datos como configuraciones flexibles."},i=void 0,s={unversionedId:"settings/README",id:"settings/README",title:"Settings",description:"Librer\xeda de Java para interpretar m\xfaltiples formatos de datos como configuraciones flexibles.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/settings/README.md",sourceDirName:"settings",slug:"/settings/",permalink:"/es/settings/",draft:!1,editUrl:"https://github.com/saicone/settings/blob/main/docs/es/README.md",tags:[],version:"current",lastUpdatedBy:"github-actions[bot]",lastUpdatedAt:1718300710,formattedLastUpdatedAt:"13 jun 2024",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Settings",description:"Librer\xeda de Java para interpretar m\xfaltiples formatos de datos como configuraciones flexibles."},sidebar:"settings"},l={},c=[{value:"Introducci\xf3n",id:"introducci\xf3n",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...r}=e;return(0,o.kt)(u,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"La librer\xeda Settings maneja diferentes formatos de datos como configuraci\xf3n en una forma flexible:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Plantillas y transformaciones de nodos."),(0,o.kt)("li",{parentName:"ul"},"Sustituci\xf3n de valores de nodos en formatos no compatibles (como json y yaml)."),(0,o.kt)("li",{parentName:"ul"},"Lector de formato opcional."),(0,o.kt)("li",{parentName:"ul"},"Nodos iterables."),(0,o.kt)("li",{parentName:"ul"},"Par\xe1metros para actualizar datos."),(0,o.kt)("li",{parentName:"ul"},"Rutas comparables para obtener nodos."),(0,o.kt)("li",{parentName:"ul"},"Valores de nodos en m\xfaltiples capas.")),(0,o.kt)("p",null,"Actualmente soportando los formatos:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/lightbend/config/blob/main/HOCON.md"},"HOCON")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://www.json.org/"},"JSON")," (usando ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/google/gson"},"Gson"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://toml.io/en/v1.0.0"},"TOML")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://yaml.org/spec/1.1/current.html"},"YAML"))),(0,o.kt)("p",null,"Tomar en cuenta que esta librer\xeda no est\xe1 enfocada como un serializador de objetos, el objetivo principal es hacer una interacci\xf3n flexible con m\xfaltiples formatos de data al mismo tiempo."),(0,o.kt)("p",null,"Tambi\xe9n tiene m\xe9todos simples para obtener nodos como m\xfaltiples tipos de datos si quieres implementar tu propio serializador de objetos."),(0,o.kt)("h2",{id:"introducci\xf3n"},"Introducci\xf3n"))}m.isMDXComponent=!0}}]);